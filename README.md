#  “哲学家就餐问题” —— 并发多任务环境编程入门

[TOC]



## 1. 引子

### 1.1. 表

#### 场景描述

> - 5 个哲学家，闲着没事做，围绕着⼀张圆桌吃⾯
> - 这个桌⼦只有 5 ⽀叉⼦，每两个哲学家之间放⼀⽀叉⼦
> - 哲学家围在⼀起思考问题，思考中途饿了就会想进餐
> - 哲学家左右手都要有⽀叉⼦才能把面吃到嘴里，不然只能等邻座的放下叉子才能就餐
> - 哲学家吃完后会把两⽀叉⼦放回原处，继续思考

<img src=".\pics\027.png" style="zoom:60%;" />

#### 极端特例

> - 五位哲学家同时停止思考，伸手拿起了左手的叉子，然后又去拿右手的叉子
> - 桌上已经没有叉子了，大家都在等邻座的放下手中的叉子
> - 没有一个哲学家能完成就餐，最后大家一起饿死

<img src=".\pics\028.png" style="zoom:60%;" />

#### 问题

> 怎样避免大家一起饿死的最坏情况？



#### 隐喻

> - 哲学家：并发多任务环境中的任务执行者 —— 线程
> - 面：任务间共享的系统 —— 文件列表、全局变量、I/O设备
> - 叉子：保证线程不会同时操作共享资源的机制 —— 锁、信号量



### 1.2. 里

#### 问题本质 —— 死锁

> 场景：
>
> - 小明和小红各拿着对方房门的钥匙
> - 小明和小红都被锁在自己的房间中
> - 小明和小红都出不了自己的房间



#### 死锁条件

> 资源互斥：小明和小红不能同时拿着同一把钥匙

<img src=".\pics\029.png" style="zoom:80%;" />



> 持有等待：
>
> - 小明等待小红放下自己房间的钥匙，同时拿着小红房间的钥匙不放
> - 小红等待小明放下自己房间的钥匙，同时拿着小明房间的钥匙不放

<img src=".\pics\030.png" style="zoom:80%;" />



> 不可剥夺：小明和小红都不能从对方手里抢钥匙

<img src=".\pics\031.png" style="zoom: 80%;" />



> 环路等待：小明和小红的等待对象构成了环路

<img src=".\pics\032.png" style="zoom:80%;" />



#### 怎样防止死锁？

> 上完课你就知道了😜



## 2. 铺垫

### 2.1. 计算硬件组成

#### 2.1.1. 从图灵机到冯诺依曼结构

##### 图灵机

> - 有1条**纸带**，纸带由一个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序；
> - 有1个**读写头**，读写头可以读取纸带上任意格?的字符，也可以把字符写入到纸带的格子；
> - 读写头上有一些部件，比如**存储单元**、**控制单元**以及**运算单元**：
>   1、存储单元用于存放数据；
>   2、控制单元用于识别字符是数据还是指令，以及控制程序的流程等；
>   3、运算单元用于执行运算指令

![](.\pics\003.jpg)

##### 冯诺依曼模型

> 在 1945 年冯诺依曼和其他计算机科学家们提出了计算机具体实现的报告，其遵循了图灵机的设计，⽽且还提出⽤电⼦元件构造计算机，并约定了⽤⼆进制进⾏计算和存储，还定义计算机基本结构为 5 个部分，分别是：
>
> - **中央处理器**：CPU，计算机的大脑
>   - 控制单元：负责控制大脑⼯作
>     - 程序计数器：下一条指令的地址
>     - 指令寄存器：未执行完的指令本身
>   - 通用寄存器：CPU中的存储器，存放数据和指令
>   - 逻辑运算单元：计算（算术、逻辑、关系、跳转...）
> - **内存**：记忆体，存放可执行文件
> - **输⼊设备**：键盘、鼠标...
> - **输出设备**：显示器、喇叭...
> - **总线**：神经网络
>   - 数据总线：传输数据和指令
>   - 地址总线：指定数据总线连接到的内存地址
>   - 控制总线：收发信号，例如中断和设备复位信号

<img src=".\pics\004.png" style="zoom:80%;" />

##### 图灵 vs 冯诺依曼

| 模型         | 组成元素            | 组成元素                             |
| ------------ | ------------------- | ------------------------------------ |
| 图灵机       | 纸带                | 读写头                               |
| 冯诺依曼模型 | 内存、输入/输入设备 | 控制单元、寄存器、逻辑运算单元、总线 |

##### 引申话题

1. CPU位宽
2. 32位和64位计算机内存寻址范围
3. 64位计算和32位计算性能差异



#### 2.1.2. 图灵机怎样执行 “a = 1 + 2” 

> 1. 读写头把 「1、 2、 +」这 3 个字符分别写⼊到纸带上的 3 个格⼦，然后读写头先停在 1 字符
>    对应的格⼦上

<img src=".\pics\039.png" style="zoom: 50%;" />



> 2. 读写头读⼊ 1 到存储设备中，这个存储设备称为图灵机的状态  

<img src=".\pics\040.png" style="zoom:53%;" />



> 3. 读写头向右移动⼀个格，⽤同样的⽅式把 2 读⼊到图灵机的状态；图灵机的状态中存储着两个连续的数字：1 和 2  

<img src=".\pics\041.png" style="zoom:55%;" />



> 4. 读写头再往右移动⼀个格
>    - 读写头读到 + 号，将 + 号传输给「控制单元」
>    - 控制单元发现是⼀个 + 号⽽不是数字，通知「运算单元」⼯作
>    - 运算单元把状态中的1 和 2 读⼊并计算，将计算的结果 3 存放到状态中  

<img src=".\pics\042.png" style="zoom:60%;" />



> 5. 运算单元将结果返回给控制单元，控制单元将结果传输给读写头，读写头向右移动，把结果 3写⼊到纸带的格⼦中

<img src=".\pics\043.png" style="zoom:45%;" />




#### 2.1.3. 现代计算机怎样执行 "a = 1 + 2"

##### 汇编

> - CPU 是不认识 “a = 1 + 2”的，将这条语句翻译成计算认识的指令的过程称为**编译**
>
> - 最终生成的可执行文件保存在内存中，包含**代码段**和**数据段**
>   - 操作数‘1’和‘2’保存在数据段中
>   - 运算指令'+'保存在代码段中

<img src=".\pics\005.png" style="zoom: 33%;" />

##### 指令周期

> 1. Fetch：取指，通过程序计数器读取对应内存地址的指令
> 2. Decode：译码，将二进制文本翻译成MIPS指令
> 3. Execution：执行，执行MIPS指令
> 4. Store：回写，计算结果回写至存储器

<img src=".\pics\006.png" style="zoom: 33%;" />



##### 引申话题

1. 计算机程序的编译过程：预编译、汇编、编译、链接
1. 指令的类型：数据传输、运算、跳转、信号、闲置
1. 指令执行速度的影响因素：指令数×CPI×时钟周期时间



#### 2.1.4. 存储器金字塔

CPU为什么要从Cache中而不是从内存中直接读取数据？

##### 存储器层次结构

> 场景：⼤学期末准备考试了，你前去图书馆临时抱佛脚
>
> - 大脑：CPU
>   - 大脑正在思考的问题：寄存器
>   - 短期记忆：L1 Cache
>   - 长期记忆：L2、L3 Cache
> - 书：内存
> - 图书馆的书架：硬盘

<img src=".\pics\008.png" style="zoom: 67%;" />

##### 存储器材料性能对比

|          | 存储器部件                               | 访问速度                               | 容量         |
| -------- | ---------------------------------------- | -------------------------------------- | ------------ |
| 寄存器   |                                          | 半个CPU时钟周期，0.5ns（2G主频，下同） | 几百到几kB   |
| L1 Cache | SRAM，易失的，速度快，密度低，不需要刷新 | 2~4 个时钟周期，约1到2ns               | 几十到几百kB |
| L2 Cache | （同上）                                 | 10~20个时钟周期，约5到10ns             | 几百kB到几MB |
| L3 Cache | （同上）                                 | 20~60个时钟周期，约10到30ns            | 几MB到几十MB |
| 内存     | DRAM，易失的、密度高，功耗低，需要刷新   | 200~300个时钟周期，约0.1到0.3us        | 几个到几十GB |
| 固态硬盘 | 非易失、材料与内存类似                   | 内存读写速度的1/1000到1/10，约150us    | 几十至几百GB |
| 机械硬盘 | 非易失、磁盘                             | 内存读写速度的1/100,000，约10ms！！！  | 几百GB到几TB |



##### CPU Cache到底有多快

> - SSD ⽐机械硬盘快 70 倍左右；
>
> - 内存⽐机械硬盘快 100000 倍左右；
>
> - CPU L1 Cache ⽐机械硬盘快 10000000 倍左右；  
>
> 如果 CPU 访问 L1 Cache 的缓存时间是 1 秒，那访问内存则需要⼤约 2 分钟，随机访问 SSD ⾥的数据则需要 1.7 天，访问机械硬盘
> 需要⻓达近 4 个⽉！！！



##### 存储器金字塔 

> - 每个存储器只和相邻的⼀层存储器设备打交道
>   - CPU 从Cache中加载数据
>   - Cache 的数据是从内存加载过来的，写回数据的时候也只写回到内存
>   - Cache 不会直接把数据写到硬盘，也不会直接从硬盘加载数据，⽽是先加载到内存，再从内存加载到Cache 中
> - 存储设备为了追求更快的速度，所需的材料成本必然也是更⾼
> - 正因为成本太⾼， CPU 内部的寄存器、 L1\L2\L3 Cache 容量较小
> - 相反内存、硬盘则可⽤更⼤的容量

<img src=".\pics\009.png" style="zoom: 67%;" />



##### 多核CPU 缓存架构

> - 每个核心各自有自己的缓存L1和L2缓存
> - L1缓存细分为数据缓存和指令缓存，大小一样
> - 核心之间共享L3缓存

<img src=".\pics\007.png" style="zoom:60%;" />



【例】：Intel i5 8250U缓存架构

<img src=".\pics\002.png" style="zoom: 90%;" />



#### 2.1.5. 怎样使程序运行的更快？程序员能做什么？

- CPU是怎样和内存交互数据的？
- 怎样减少CPU操作内存的次数？



##### 缓存行（Cache Line）

> 如果32位CPU操作内存的基本单位是4个字节，那么Cache读内存的基本单位就是Cache Line。可以认为Cache Line就是一片物理地址连续的内存块，例如64字节。



##### 缓存行和内存块的映射关系

> 直接映射：
>
> - 物理地址按Cache Line大小分块，称为Block
> - Block和Cache Line之间是多对一的关系
> - Cache Line当前指向的Block由**Cache Lin数据结构**中的**组标记（Tag）**决定
> - CPU通过组标记辨别Cache Line是否对应到自己想要的Block

<img src=".\pics\010.png" style="zoom:60%;" />

##### CPU读写数据的方式

> - **Cache Line数据结构**中的**有效位（Valid Bit）**用于标记Cache Line中数据的有效性
> - CPU写数据时会先检查Cache Line的组标记，看看数据是否在Cache中
>   - 如果在Cache中则直接写Cache Line中该数据的地址，并置位有效位，标记Cache Line中有”脏数据“
>   - 如果没有则先将数据所在的内存Block加载到Cache中，再重复上一操作
> - CPU读数据时同样先检查Cache Line的组标记，看看是否已经加载过了
>   - 如果已经在Cache中了，则直接读取
>   - 如果没有则先将内存Block加载到Cache中，再从Cache中读取
> - 不管读还是写，如果数据不在Cache中，CPU都需要将内存Block加载到Cache Line中
>   - 加载数据前，CPU需要通过有效位检查Block所映射到的Cache Line中是否有”脏数据“
>     - 如果有，说明Cache中的数据和内存不一样，CPU在加载Block前会先把Cache Line回写到内存中
>     - 如果没有，则不用执行上一操作

<img src=".\pics\011.png" style="zoom: 67%;" />

##### 缓存命中率

> 缓存命中率指在一段时间，CPU直接从缓存中访问数据的次数占总访问次数的比率，缓存命中率越高，程序运行地越快
>
> 提高缓存命中率的理论依据：局部性原理（有兴趣自己去看吧🤣）
>
> - 数据命中率：
>   - 把短时间内需要集中操作的数据放在连续的地址中
>   - 或不要集中操作物理地址分散的数据
> - 指令命中率
>   - 尽量使条件分支变得”有规律“，以提高分支预测器的准确性

```C
/* 先行后列还是先列后行？ */

int array[M][N];

/* 访问方式一：先行后列 */
for(int i = 0; i < M; i++) {
    for(int j = 0; j < N; j++) {
        array[i][j] = 0;
    }
}

/* 访问方式二：先列后行 */
for(int j = 0; j < N; j++) {
    for(int i = 0; i < N; i++) {
        array[i][j] = 0;
    }
}
```

```C
/* 先排序后遍历还是先遍历后排序 */
int array[N] = {....};

/* 遍历数组，根据成员大小不同采用不用操作 */
#define traverse do {				\
	for(int i = 0; i < N; i++) {	\
		if(50 < array[i]) {			\
			array[i] = 0;			\
		} else {					\
			array[i] += 1;			\
		}							\
	}								\
} while (0)

/* 方式一：先遍历后排序 */
do {
    traverse;
    sort(array, N);
} while (0);

/* 方式二：先排序后遍历 */
do {
    sort(array, N);
    traverse;
} while (0);

```



##### 引申话题

1. CPU更新数据的两种策略：写直达和写回
2. 多核CPU确保缓存一致性的策略：MESI协议
3. 多核CPU缓冲失效问题：数据的伪共享及如何避免



### 2.4. 虚拟内存

单片机为什么不能同时运行多个程序，Windows、Linux为什么可以?



##### 单片机管理内存的方式

> CPU直接操作物理地址，程序的内存空间在物理上是冲突的，例如：
>
> 1. 程序A获得CPU使用权，对地址0x2000中的数据进行了修改，程序A让出CPU使用权；
> 2. 程序B获得CPU使用权，再次对地址0x2000中数据进行操作，写入了不同的数据，程序B让出CPU使用权；
> 3. 程序A再次获得CPU使用权，程序A读地址0x2000中的数据，很不巧，由于B的修改导致程序A出错了，系统崩溃。

<img src=".\pics\012.png" style="zoom:60%;" />



##### 虚拟内存：CPU和物理内存接口

> - 操作系统为每个进程分配相互独立的地址空间，在每个进程看来他们使用的地址是一样的
> - 进程所”看到“的地址称为**虚拟地址**
> - 操作系统负责处理虚拟地址和物理地址之间的映射关系，为每个进程分配实际使用的**物理地址**
> - 实际的效果是，进程使用了不同的物理地址，而他们自己是不知道的（不识庐山真面目，只缘身在此山中😅）

<img src=".\pics\013.png" style="zoom:75%;" />

##### linux管理内存的方式

> - 虚拟地址分为内核空间和用户空间两部分
>   - 内核空间关联的是相同的物理地址
>   - 用户空间关联的时不同的物理地址
> - 进程在用户态时只能访问用户空间的内存
> - 进程进入内核态后才可以访问内核空间的内存

<img src=".\pics\014.png" style="zoom:60%;" />



##### linux用户空间的内存分布（以32位系统为例）

>⽤户空间内存，从低到⾼分别是 7 种不同的内存段：
>
>* 程序⽂件段，包括⼆进制可执⾏代码
>* 已初始化数据段，包括静态常量
>* 未初始化数据段，包括未初始化的静态变量
>* 堆段，包括动态分配的内存，从低地址开始向上增⻓
>* ⽂件映射段，包括动态库、共享内存等，从低地址开始向上增⻓（跟硬件和内核版本有关）
>* 栈段，包括局部变量和函数调⽤的上下⽂等
>* 栈的⼤⼩是固定的，⼀般是 8 MB；大小可通过系统提供的参数调整

<img src=".\pics\015.png" style="zoom:50%;" />



##### 引申话题：

1. 操作系统管理虚拟地址物理地址关系的方式：内存分段、内存分页、段页式管理
2. ELF文件
3. 栈的数据结构：有序性（数组、链表）
4. 堆的数据结构：无序性（二叉树）



### 2.3. 操作系统和内核

怎样避免多个进程打起来😂？

##### 内核

> - 定义：进程使用物理设备（CPU、内存、输入/输出设备）的桥梁
> - 功能
>   - 任务管理：进程和线程的调度 —— *什么时间谁可以使用CPU*
>   - 内存管理：内存的分配和释放 —— *谁使用哪块物理内存以及怎么用*
>   - 设备管理：与硬件设备通信的能力 —— *进程不需要关心硬件设备的差异，一切皆文件*
>   - 系统调用：应用程序与操作系统间的接口 —— *进程从用户态进入内核态的通道*



##### 为什么要提供系统调用

> 进程在用户态只能访问局部的内存空间，而在内核态则可以访问所有的内存空间；系统调用为进程提供了从用户态进入内核态的接口

<img src=".\pics\016.png" style="zoom:75%;" />

##### 操作系统分类

> - 宏内核
>   - 内核包括所有模块（任务调度、设备驱动、文件系统、...），整个内核是完整的程序
>     - 设备驱动操作硬件时不需要在用户态和内核态之间切换
>   - 【例】Linux
> - 微内核
>   - 内核只保留基本功能（任务调度、内存管理、中断、...），部分功能让渡到用户态执行（设备驱动、文件系统）
>     - 内核易于移植，服务间隔离，稳定性高
>     - 设备驱动需要频繁地在用户态和内核态之间作切换
>   - 【例】鸿蒙
> - 混合内核
>   - 内核中包含抽象出的微内核，其它模块在微内核基础上搭建，整个内核是完整的程序
>   - 【例】Windows NT

![](.\pics\017.png)



##### Linux 的特点

> - Multitask：多任务
> 	并行（多核）、并发（单核）处理多任务
> - SMP：对称多处理
> 	  每个内核都可以完整地访问所有内存空间和硬件资源
> - ELF：可执行文件链接格式
> - Monolithic Kernel：宏内核



### 2.4. 进程和线程

操作系统是如何让CPU“弹钢琴”的？

#### 2.4.1. 任务

###### 并发？还是并行？

> - 并发
>   - 单核CPU或多核CPU的一个核心处理多个任务
>   - 调度器将CPU分片，在每个时间片执行不同任务
> - 并行
>   - CPU不同核心处理各自不同的任务

<img src=".\pics\018、.png" style="zoom:50%;" />



###### 任务

> - 线程是生存在进程中的业务流程，分享系统分配给进程的资源，包括：地址空间、代码段、文件描述符列表...
> - 内核统一调度单线程进程或进程中的线程，这些调度单位称为**任务**，用结构体**task_struct**描述

<img src=".\pics\019.png" style="zoom:60%;" />



###### 引申话题

1. Linux任务分级：实时任务（优先级0 ~ 99），普通任务（优先级100 ~ 139）
2. Linux任务队列：dl_rq、rt_rq、cfs_rq



#### 2.4.2. 进程

###### PCB——进程控制块

> - 定义：Process Control Block，操作系统描述进程的数据结构，进程调度器的操作对象
>
> - PCB的成员：
>
>   - 进程描述信息
>
>     - 进程标识 —— 进程的身份证
>
>     - 用户标识 —— 进程归属的用户
>
>   - 进程管控信息
>   
>        - 进程状态 —— ｛就绪，运行，阻塞，创建，结束，就绪挂起，阻塞挂起}
>        - 进程优先级 —— 谁先使用CPU
>   
>   - 进程资源信息
>   
>        系统为进程分配的资源
>
>        - 地址空间或虚拟内存信息
>        - 打开的文件列表
>        - 使用的I/O设备信息
>   
>   - CPU状态
>   
>        - 上下文：**指令寄存器**和**程序计数器**
>        - 通用寄存器的状态
>   



###### 进程的状态

> 进程 —— 后宫佳丽
>
> CPU —— 皇上
>
> 调度器 —— 管事的公公
>
> - 基本状态
>   - Running 运行：进程正在被CPU宠幸
>   - Blocked 阻塞：进程回宫取东西，不能被公公调度
>   - Ready 就绪：进程可以被公公调度，等待CPU“临幸”🙈
> - 触发状态转换的事件
>   - 运行-->就绪：时辰已到（时间片用完），CPU的宠幸被公公强行中断
>   - 运行-->阻塞：进程要回宫拿东西，主动放弃了CPU的宠幸
>   - 阻塞-->就绪：进程拿到东西了
>   - 就绪-->运行：进程被“公公”选中

<img src=".\pics\020.png" style="zoom:60%;" />

###### 进程的组织和控制

> 进程的一种组织方式：链表
>
> - 具有相同状态的PCB链在一起组成一个队列：处于就绪状态和阻塞状态的进程各自链接成就绪队列和阻塞队列
>
> - 进程的控制
>
>   - 创建
>     - 分配进程标识符
>     - 申请和初始化PCB
>     - 将进程插入就绪队列，等待被唤醒
>
>   - 终止
>     - 查找进程的PCB
>     - 若处于运行状态则立即终止，将CPU分配给其他进程
>     - 终止所有子进程
>     - 将资源归还父进程或操作系统
>
>   - 阻塞
>     - 查找PCB
>     - 若进程正在运行则：保护现场、修改状态、停止运行
>     - 修改PCB状态，并将其插入到阻塞队列
>
>   - 唤醒
>     - 从阻塞队列中查找PCB
>     - 修改PCB状态，并将其插入到就绪队列

<img src=".\pics\021.png" style="zoom:60%;" />

###### 引申话题

1. 上下文切换过程中发生了什么
2. 用户线程、内核线程
3. 用户线程与内核线程的对应关系
4. 调度算法：先来先服务、最短作业优先、高响应比优先、时间片轮转、最高优先级、多级反馈队列



#### 2.4.3. 进程和线程比较

###### 功能

> 进程和线程都是为任务的并发处理服务的



###### 资源

> - 进程是资源分配的基本单位，每个进程拥有独立的资源，包括：
>
>   - 内核态：寄存器状态、内核堆栈
>
>   - 用户态：虚拟内存信息、全局变量、文件列表、设备使用信息
>
> - 线程是任务调度的基本单位，分享进程创建的大部分资源，仅保留必要的信息



###### 状态

> 线程和进程都具有三种基本状态，且转换触发事件相同：就绪、阻塞、运行



###### 调度

> - 进程运行在内核态，由内核调度
> - 线程可以运行在用户态，由用户态库函数负责调度，可以运行在单片机中



###### 切换

> - 进程需要更换整个PCB表，开销大
> - 用户态线程只需要更新CPU上下文，不用重新分配资源，也不用调用系统接口在用户态和内核态之间作切换，开销小



### 2.5. 进程间怎样通信

#### 2.5.1. 管道 —— 最便捷的通信方式

##### 无名管道

```shell
$ ps auxf | grep mysql
```

> “ | ”：无名管道
>
> 作用：将前一个命令（ps auxf）的输出作为后一个命令（grep mysql）的输入
>
> 特点：
>
> - 内核中的一段缓存
> - 字节流传输
> - 没有文件描述符
> - 只用用于具有亲缘关系的进程之间单向通信
> - 生命周期在进程结束后终结

<img src=".\pics\022.png" style="zoom:75%;" />

##### 有名管道

 ```shell
 $ mkfifo myPipe
 $ ls -l
 prw-r--r--. 1 root	root		0 Jul 17 02:45 myPipe
 ```

> 特点：
>
> - 文件类型描述符：'p'
> - 有文件描述符：可用于无亲缘关系的进程间通信
> - 生命周期随操作系统



#### 2.5.2 消息队列

- 存储在内核缓存中的消息块链表
- 数据传输格式为固定格式的消息块
- 消息块大小有限制
- 通信效率低，主要是内核态和用户态切换过程中的开销



#### 2.5.3. 共享内存 —— 最快捷的通信方式

> 思路：
>
> - 用同一块物理内存映射进程A、B各自的某块虚拟空间
> - 进程A、B操作各自的虚拟空间后对方立即可以看到
>
> 优点：
>
> - 通信操作在用户态完成，不用切换到内核态再切换回来，开销小
> - 不需要拷贝数据
>
> 缺点：
>
> - 进程间需要协商好操作共享资源的方式
>
> PS：进程A、B操作共享资源的代码段称为**临界区**

<img src=".\pics\023.png" style="zoom:60%;" />



#### 2.5.4. 信号量 —— 用于在进程间传递共享资源的使用情况

> 信号量其实是⼀个整型的计数器，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据
>
> - 信号量的原子操作
>
>   - P 操作：将信号量减去 1
>
>     - 相减后信号量 < 0：资源已被占⽤，进程需阻塞等待
>
>     - 相减后信号量 >= 0：资源可使⽤，进程可正常继续执⾏
>   
>   - V 操作：将信号加上 1
>     - 相加后信号量 <= 0：当前有阻塞中的进程，调度器将被阻塞的进程唤醒运⾏
>     - 相加后信号量 > 0：当前没有阻塞中的进程
>



##### 互斥

> - 过程分析
>
>   1. 信号量初始值为 1
>
>   2. 进程 A 进入临界区前执⾏ P 操作，信号量变为 0，共享资源可⽤，进程 A 进入临界区
>
>   3. 进程 B 稍慢一步，执⾏ P 操作尝试进去临界区，信号量变为 -1，共享资源被占⽤，进程 B 阻塞等待
>
>   4. 进程 A 离开临界区，执⾏ V 操作，信号量恢复为 0，调度器有进程被阻塞，仔细一看是进程B，于是唤醒B进程
>
>   5. 进程 B 进入临界区，B进程离开临界区，执行V操作，信号量量变为1，调度器没有发现被组素的进程，什么也不做
>
> - 特点
>   - 信号量初值为 1
>   - 进程关系平等
>   - P、V操作成对出现
>   - P操作在V操作前

<img src=".\pics\024.png" style="zoom:60%;" />



##### 同步

> - 分析
>   1. 信号量初始值为 0
>   2. 进程A生产数据，进程B尝试进去临界区，执行P操作，信号量变为-1，资源不可用，信号量阻塞等待
>   3. 进程A生产完数据，执行V操作，信号量变为0，调度器检查阻塞队列，发现一只憨憨（进程B）在里面，于是唤醒他😂
>   4. 进程B进入临界区使用数据
>
> - 特点
>   - 信号量初始值为 0
>   - 进程关系不平等，分为生产者和消费者两类
>   - 生产者执行V操作，消费者执行P操作

<img src=".\pics\025.png" style="zoom:60%;" />



#### 2.5.5. 信号 —— 唯一的异步通信机制

> 异常工作模式下，硬件I/O设备设备、脚本程序向进程传递各种事件消息的方式
>
> 【例】：shell 终端中输入 Ctrl + C 产生**SIGINT**信号，表示终止该进程；输入 Ctrl + Z 产生SIGSTOP信号，表示暂停该进程

```shell
$ kill -l
1) SIGHUP		2)	SIGINT		3)	SIGQUIT		4) SIGILL		5) SIGTRAP
6) SIGABRT		7)	SIGBUS		8)	SIGFPE		9) SIGKILL		10) SIGUSR1
11) SIGSEGV		12) SIGUSR2 	13) SIGPIPE		14) SIGALRM		15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD 	18) SIGCONT		19) SIGSTOP		20) SIGTSTP
21) SIGTTIN		22) SIGTTOU 	23) SIGURG		24) SIGXCPU		25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF 	28) SIGWINCH	29) SIGIO		30) SIGPWR
31) SIGSYS		34) SIGRTMIN 	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10 55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX
```



#### 2.5.6. 套接字 —— 可用于不同主机的进程间通信

> 网络层次模型中应用层软件使用的文件描述符
>
> - 分类
>
>   - TCP字节流
>
>   - UDP数据报
>
>   - 本地字节流或本地数据报
>
> PS：套接字**非常非常非常重要！！！**，这里暂时略过是因为内容太多，需要单独讲解🙁



#### 2.5.7. 引申话题

1. 计算机网络编程：TCP编程、UDP编程



### 2.6. 信号量和锁

#### 2.6.1. 锁

> 与信号量类似，锁是专门用来进行互斥的
>
> - 按等待资源的模式分为：
>   - 忙等待锁：没有资源时while(1)循环，又称自旋锁，用在临界区任务量特别小的环境，优点是不需要进入内核态阻塞自己
>   - 无忙等待锁（互斥锁）：没有资源时阻塞自己，需要进入内核态，用在临界区任务量大，状态转换开销相对较小的环境
> - 按对待资源的态度分为：
>   - 悲观锁：认为不同进程操作相同的资源必然造成冲突，因此进去临界区必须加锁，自旋锁、互斥锁都是悲观锁
>   - 乐观锁：认为不同进程操作相同资源不一定造成冲突，只需要记住资源之前的样子，如果冲突再恢复就是了（实际上根本没有锁，骗子🤣）
>     - 不要小看乐观锁，在线文档、大名鼎鼎的Git版本管理都是按这种思路设计的
>
> PS：锁的内容很丰富也很有意思，但入门教程主要是讲资源保护的思路，因此这里就不展开了



##### 互斥锁的例子

![互斥锁](.\pics\001.png)

#### 2.6.2. 信号量

##### 互斥 —— “丈夫与妻子”模型

> 场景：
>
> 1. 早上起床后，夫妻俩争抢洗手间
> 2. 妻子动作快先抢到（P操作）
> 3. 妻子使用洗手间（临界区，使用资源）
> 4. 丈夫动作慢，等妻子用完（P操作）
> 5. 妻子用完洗手间，让出洗手间（V操作）
> 6. 丈夫使用洗手间（临界区，使用资源）
> 7. 丈夫用完洗手间，让出洗手间（V操作）

```C
#include <stdio.h>
#include <stdbool.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

sem_t s_wc; // 卫生间信号量：表示卫生间是否被占用

#define P(s) sem_wait(&s)
#define V(s) sem_post(&s)

/*
 * 丈夫线程函数
 **/
static void* sTaskHusbend(void *arg) {
    printf("老公起床\n");
    sleep(5);

    printf("老公问洗手间里有没有人: s_wc == %d, P(s_wc)\n", s_wc.__align);
    P(s_wc);

    printf("老公使用洗手间...\n");
    sleep(3);

    V(s_wc);
    printf("老公用完洗手间: V(s_wc), s_wc == %d\n", s_wc.__align);

    printf("老公出门上班\n");
}

/*
 * 妻子线程函数
 **/
static void* sTaskWife(void *arg) {
    printf("老婆起床\n");
    sleep(3);

    printf("老婆问洗手间里有没有人: s_wc == %d, P(s_wc)\n", s_wc.__align);
    P(s_wc);

    printf("老婆使用洗手间...\n");
    sleep(8);

    V(s_wc);
    printf("老婆用完厕所: V(s_wc), s_wc == %d\n", s_wc.__align);

    printf("老婆出门上班\n");
}

int main(void) {

    sem_init(&s_wc, 0, 1); // 初始化洗手间信号量

    pthread_t tid_h, tid_w;
    pthread_create(&tid_h, NULL, sTaskHusbend, NULL); //创建老公任务线程
    pthread_create(&tid_w, NULL, sTaskWife, NULL); //创建老婆任务线程

    pthread_join(tid_h, NULL); //阻塞等待老公线程汇合
    pthread_join(tid_w, NULL); //阻塞等待老婆线程汇合

    return 0;
}
```



##### 协作 —— “儿子与母亲”模型

> 场景：
>
> 1. 儿子饿了通知母亲做饭，儿子等待（V操作）
> 2. 母亲得知儿子饿了（P操作）
> 3. 母亲开始做饭（生产资源）
> 4. 母亲做好饭通知儿子来吃（V操作）
> 5. 儿子得知饭做好开始吃饭（P操作）
> 6. 儿子吃饭（使用资源）

```C
#include <stdio.h>
#include <stdbool.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

sem_t s_son; // 儿子信号量：表示需不需要吃饭
sem_t s_mum; // 母亲信号量：表示饭做没做好

#define P(s) sem_wait(&s)
#define V(s) sem_post(&s)

/*
 * 儿子线程函数
 **/
static void* sTaskSon(void *arg) {
    sleep(5);

    V(s_son);
    printf("儿子饿了，叫妈妈做法: V(s_son), s_son == %d\n", s_son.__align);

    printf("儿子等待妈妈做好饭: s_mum == %d, P(s_mum)\n", s_mum.__align);
    P(s_mum);
      
    printf("儿子吃饭...\n");
    sleep(5);

    printf("儿子吃完饭\n");
}

/*
 * 母亲线程函数
 **/
static void* sTaskMum(void *arg) {
    printf("妈妈等待儿子的召唤: s_son == %d, P(s_son)\n", s_son.__align);
    P(s_son);

    printf("妈妈做饭...\n");
    sleep(5);

    V(s_mum);
    printf("妈妈做好饭叫儿子来吃: V(s_mum), s_mum == %d\n", s_mum.__align);
}

int main(void) {

    sem_init(&s_son, 0, 0); // 初始化儿子信号量为 0，表示不需要吃饭
    sem_init(&s_mum, 0, 0); // 初始化母亲信号量为 0，表示饭没做好

    pthread_t tid_son, tid_mum;
    pthread_create(&tid_son, NULL, sTaskSon, NULL); //创建儿子任务线程
    pthread_create(&tid_mum, NULL, sTaskMum, NULL); //创建母亲任务线程

    pthread_join(tid_son, NULL); //阻塞等待儿子线程汇合
    pthread_join(tid_mum, NULL); //阻塞等待母亲线程汇合

    return 0;
}
```



##### 死锁 —— “外星司机”模型

> 场景：
>
> 1. 三个地球司机共用同一台车，大家约定好使用车子时总是先拿到钥匙后再开车，彼此相安无视
> 2. 有一天来了一个外星司机，外星司机不知道地球的规矩，开车是新进车子里再用意念隔空取钥匙，结果悲剧了：
>    - 外星司机在车子里拿不到钥匙，因为钥匙被某个司机拿了
>    - 某个地球司机拿着钥匙确开不了车，因为驾驶座被外星司机占了
>    - 大家就这样你看我我看你，直到你按下 Ctrl + C
> 3. 外星司机熟悉地球后也学着地球人先找到钥匙再进车子，然后大家又相安无事，重新过上了没羞没臊的快乐生活

 ```c
 #include <stdio.h>
 #include <stdbool.h>
 #include <string.h>
 #include <unistd.h>
 #include <pthread.h>
 #include <semaphore.h>
 
 sem_t s_car; //汽车信号量：表示驾驶室是否有人
 sem_t s_key; //钥匙信号量：表示车钥匙有没有被拿走
 
 #define P(s) sem_wait(&s)
 #define V(s) sem_post(&s)
 
 /*
  * 正常司机线程函数
  **/
 static void* sTaskNormalDriver(void *arg) {
 
     printf("正常司机%d准备出门\n", *((int *)arg));
     sleep(2);
 
     printf(
         "正常司机%d找钥匙: s_key == %d, P(s_key)\n"
     ,   *((int *)arg)
     ,   s_key.__align
     );
     P(s_key);
     usleep(100000);
 
     printf(
         "正常司机%d找车: s_car == %d，P(s_car)\n"
     ,   *((int *)arg)
     ,   s_car.__align
     );
     P(s_car);
 
     printf("正常司机%d开车...\n", *((int *)arg));
     sleep(2);
 
     printf("正常司机%d停车...\n", *((int *)arg));
     sleep(1);
 
     V(s_car);
     printf(
         "正常司机%d从车里出来: V(s_car), s_car == %d\n"
     ,   *((int *)arg)
     ,   s_car.__align
     );
 
     usleep(100000);
 
     V(s_key);
     printf(
         "正常司机%d还钥匙: V(s_key), s_key == %d\n"
     ,   *((int *)arg)
     ,   s_key.__align
     );
 }
 
 /*
  * 外星司机函数
  **/
 static void* sTaskAlienDriver(void *arg) {
     printf("外星司机准备出门\n");
     sleep(2);
 
     if(
         arg != NULL
     &&  !strcmp((char *)arg, "educated")
     ) {
         printf("外星司机先找钥匙后找车\n");
         printf("外星司机找钥匙: s_key == %d, P(s_key)\n", s_key.__align);
         P(s_key);
 
         usleep(100000);
 
         printf("外星司机找车: s_car == %d，P(s_car)\n", s_car.__align);
         P(s_car);
     } else {
         printf("外星司机先找车后找钥匙\n");
         printf("外星司机找车: s_car == %d，P(s_car)\n", s_car.__align);
         P(s_car);
 
         usleep(100000);
 
         printf("外星司机找钥匙: s_key == %d, P(s_key)\n", s_key.__align);
         P(s_key);
     }
 
     printf("外星司机开车...\n");
     sleep(2);
 
     printf("外星司机停车...\n");
     sleep(1);
 
     if(
         arg != NULL
     &&  !strcmp((char *)arg, "educated")
     ) {
         V(s_car);
         printf("外星司机从车里出来: V(s_car), s_car == %d\n", s_car.__align);
     
         usleep(100000);
     
         V(s_key);
         printf("外星司机还钥匙: V(s_key), s_key == %d\n", s_key.__align);
     } else {
         V(s_key);
         printf("外星司机还钥匙: V(s_key), s_key == %d\n", s_key.__align);
 
         usleep(100000);
 
         V(s_car);
         printf("外星司机从车里出来: V(s_car), s_car == %d\n", s_car.__align);
     }
 }
 
 int main(int argc, char **argv) {
 
     if(
         argv[1] != NULL
     &&  !strcmp(argv[1], "ufo")
     ) {
         printf("混入了一只外星司机\n");
 
         if(
             argv[2] != NULL
         &&  !strcmp(argv[2], "educated")
         ) {
             printf("外星司机熟悉了地球生活\n");
         }
     }
 
     sem_init(&s_car, 0, 1); // 初始化汽车信号量为 1，表示汽车没人开
     sem_init(&s_key, 0, 1); // 初始化钥匙信号量为 1，表示钥匙没人用
 
     pthread_t tid_nd[3], tid_ad;
     int nd_id[3] = {1, 2, 3};
 
     pthread_create(  //创建正常司机1任务线程
         &tid_nd[0]
     ,   NULL
     ,   sTaskNormalDriver
     ,   &nd_id[0]
     );
 
     pthread_create(  //创建正常司机2任务线程
         &tid_nd[1]
     ,   NULL
     ,   sTaskNormalDriver
     ,   &nd_id[1]
     );
 
     pthread_create(  //创建正常司机3任务线程
         &tid_nd[2]
     ,   NULL
     ,   sTaskNormalDriver
     ,   &nd_id[2]
     );
 
     if(
         argv[1] != NULL
     &&  !strcmp((char *)argv[1], "ufo")
     ) {
 
         pthread_create(  //创建外星司机任务线程
             &tid_ad
         ,   NULL
         ,   sTaskAlienDriver
         ,   argv[2]
         );
     }
 
     for(int i = 0; i < 3; i ++) {
         pthread_join(tid_nd[i], NULL); //阻塞等待正常司机线程汇合
     }
 
     if (
         argv[1] != NULL
     &&  !strcmp((char *)argv[1], "ufo")
     ) {
         pthread_join(tid_ad, NULL); //阻塞等待外星司机线程汇合
     }
 
     return 0;
 }
 ```



## 3. 帮助哲学家吃饭

### 3.1. 方案一（不能避免死锁的方案）

#### 思路

> 有叉子就直接拿起来，没叉子就等其它哲学家放回去

<img src=".\pics\033.png" style="zoom: 80%;" />



#### 下场

> 大家一起饿死

<img src=".\pics\028.png" style="zoom:60%;" />



#### 一起饿死的原因（用死锁四条件分析）

> - 互斥：邻座的哲学家不能同时使用他们之间的叉子
> - 持有等待：哲学家等待邻座的哲学家用完叉子时不会放下手上已经拿着的叉子
> - 不可剥夺：哲学家不能从邻座的哲学家手里抢叉子
>
>
> - 环路等待：每位哲学家们左手都持有叉子时，所有人都无法就餐，因为每个人都在等待他们右边的放下左手的叉子
>



### 3.2. 方案二

#### 思路

> 哲学家要么不取要么同时拿走两把叉子
>
> - 破坏的条件：持有等待 —— 不会出现手上拿着一把叉子等待另一把的情况

<img src=".\pics\034.png" style="zoom:80%;" />

#### 问题

> 每次只能有一位哲学家就餐，其他哲学家只能等他吃完，桌上放两把叉子就够了

<img src=".\pics\035.png" style="zoom:70%;" />



### 3.3. 方案三

#### 思路

> 哲学家按不同的顺序取叉子
>
> - 奇数哲学家先左后右
> - 偶数哲学家先右后左
> - 破坏的条件：环路等待 —— 持有等待的对象不会构成环路

<img src=".\pics\037.png" alt="037" style="zoom:80%;" />



#### 效果不错🙂

> 即不会死锁，也可以保证同时有两位科学家在用餐

<img src=".\pics\036.png" style="zoom:75%;" />

### 3.4. 方案四（换个角度看问题）

#### 思路

> 建立相邻哲学家之间的联系，使他们各自成为对方生产者或消费者：
>
> - 只有当与之相邻的哲学家完成就餐，哲学家才会取用他们之间的叉子
> - 破坏的条件：互斥 —— 将邻座哲学家对叉子的竞争关系转换成了协作关系

<img src=".\pics\038.png" style="zoom:80%;" />





# Fin

**感谢大家的参与！**

